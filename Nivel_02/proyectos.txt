##########################################################
################## ESTRUCTURA DE CLASES ##################
##########################################################

ğŸš€ PROYECTO 1 â€” Sistema de Cuentas Bancarias (Modificadores de Acceso)
    ğŸ“Œ SituaciÃ³n real
        EstÃ¡s programando el nÃºcleo de un sistema bancario.
        No cualquier parte del sistema debe poder ver o modificar los datos de una cuenta.
    ğŸ§© Requisitos reales
        Existe una clase CuentaBancaria
        La cuenta tiene:
            NÃºmero de cuenta
            Saldo
            Tipo de cuenta
        Reglas reales:
            El saldo no puede modificarse directamente desde fuera
            El nÃºmero de cuenta no debe cambiar nunca
            El tipo de cuenta solo puede ser usado por clases del mismo mÃ³dulo
        Existe un paquete externo que intenta:
            Consultar datos permitidos
            Modificar datos que no deberÃ­a poder
    ğŸ“¤ Resultado esperado (conceptual)
        Saldo actualizado correctamente
        Acceso denegado
    ğŸ”¥ Se evalÃºa
        Uso real de private
        Uso real de default (package-private)
        Uso de public solo donde corresponde
        EncapsulaciÃ³n como en un sistema financiero

ğŸš€ PROYECTO 2 â€” Registro de Usuarios (Constructores y Herencia)
    ğŸ“Œ SituaciÃ³n real
        Un backend registra usuarios provenientes de distintas fuentes.
    ğŸ§© Requisitos reales
        Existe una clase base Usuario
        Todo usuario debe tener:
            ID
            Fecha de registro
        Existen mÃºltiples formas de registrar usuarios:
            Registro manual
            Registro automÃ¡tico del sistema
        Las reglas:
            Todos los usuarios deben quedar vÃ¡lidos
            No se puede repetir lÃ³gica entre constructores
            La inicializaciÃ³n debe ser clara y segura
    ğŸ“¤ Resultado esperado (conceptual)
        Usuario registrado con ID: 1024
    ğŸ”¥ Se evalÃºa
        Uso real de this() para encadenar constructores
        Uso correcto de super()
        ComprensiÃ³n del orden de inicializaciÃ³n
        DiseÃ±o limpio de constructores

ğŸš€ PROYECTO 3 â€” ConfiguraciÃ³n Global del Sistema (static y final)
    ğŸ“Œ SituaciÃ³n real
        Tu aplicaciÃ³n necesita configuraciÃ³n global: puertos, nombre de app, modo debug.
    ğŸ§© Requisitos reales
    Existe una clase AppConfig
    Reglas estrictas:
        No debe poder heredarse
        Los valores no deben cambiar en tiempo de ejecuciÃ³n
        La configuraciÃ³n se carga una sola vez
    La app debe:
        Acceder a los valores desde cualquier clase
        Ejecutar lÃ³gica al arrancar la aplicaciÃ³n
    ğŸ“¤ Resultado esperado (conceptual)
        Cargando configuracion...
        Aplicacion iniciada en puerto 8080
    ğŸ”¥ Se evalÃºa
        Uso real de static
        Uso real de final
        Bloques estÃ¡ticos de inicializaciÃ³n
        Constantes pÃºblicas
        DiseÃ±o inmutable como en backend real

ğŸš€ PROYECTO 4 â€” Sistema de Notificaciones (Error CrÃ­tico sin @Override)
    ğŸ“Œ SituaciÃ³n real
        Tu backend envÃ­a notificaciones por distintos canales: email, SMS y push.
        Un bug llegÃ³ a producciÃ³n porque una clase creÃ­a estar sobrescribiendo un mÃ©todoâ€¦ pero no lo estaba.
    ğŸ§© Requisitos reales
        Existe una clase base Notificacion
        Define un mÃ©todo para enviar el mensaje
        Existen implementaciones concretas:
            Email
            SMS
            Push
        El sistema:
            Ejecuta el envÃ­o desde una referencia del tipo base
            Debe garantizar que cada implementaciÃ³n se ejecute correctamente
        Cualquier error de sobrescritura debe detectarse en compilaciÃ³n
    ğŸ“¤ Resultado esperado (conceptual)
        Enviando email...
        Enviando SMS...
        Enviando push...
    ğŸ”¥ Se evalÃºa
        Uso obligatorio de @Override
        PrevenciÃ³n de errores por firmas mal escritas
        Polimorfismo real
        CÃ³digo seguro para producciÃ³n

ğŸš€ PROYECTO 5 â€” Procesador de Pagos (Casting Seguro)
    ğŸ“Œ SituaciÃ³n real
        Un sistema procesa pagos que llegan desde distintas pasarelas.
    ğŸ§© Requisitos reales
        Existe una clase base Pago
        Existen distintos tipos de pago:
            Tarjeta
            Transferencia
            Criptomoneda
        El sistema recibe una referencia genÃ©rica (Pago)
        Antes de ejecutar lÃ³gica especÃ­fica:
            Debe verificar el tipo real del objeto
            Nunca debe lanzar ClassCastException
        El flujo debe ser claro y mantenible
    ğŸ“¤ Resultado esperado (conceptual)
        Procesando pago con tarjeta
        Procesando transferencia bancaria
        Procesando pago con criptomoneda
    ğŸ”¥ Se evalÃºa
        Uso correcto de instanceof
        Casting seguro
        DiseÃ±o defensivo
        CÃ³digo robusto en tiempo de ejecuciÃ³n

ğŸš€ PROYECTO 6 â€” Motor de Reglas (Pattern Matching for instanceof)
    ğŸ“Œ SituaciÃ³n real
        Un backend aplica reglas distintas segÃºn el tipo de evento recibido.
    ğŸ§© Requisitos reales
        Existe una jerarquÃ­a de eventos:
            EventoUsuario
            EventoSistema
            EventoError
        El sistema recibe eventos como tipo base
        Debe:
            Detectar el tipo concreto
            Ejecutar lÃ³gica especÃ­fica
            Evitar casts explÃ­citos repetitivos
        El cÃ³digo debe ser:
            Legible
            Moderno
            FÃ¡cil de extender
    ğŸ“¤ Resultado esperado (conceptual)
        Evento de usuario procesado
        Evento del sistema procesado
        Evento de error procesado
    ğŸ”¥ Se evalÃºa
        Uso de instanceof con pattern matching (Java 14+)
        EliminaciÃ³n de casts manuales
        CÃ³digo limpio y expresivo
        Buen diseÃ±o orientado a objetos

