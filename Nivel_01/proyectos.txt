##########################################################
################ TIPOS DE DATOS Y MEMORIA ################
##########################################################

ğŸš€ PROYECTO 1 â€” Analizador de Entradas del Usuario
    ğŸ“Œ Contexto
        Un programa recibe datos como texto (simulando una API o un formulario).
    ğŸ§© Requisitos
        Recibe un String con datos separados por ;
        Cada dato puede ser:
            Un nÃºmero entero
            Un nÃºmero decimal
            Texto vacÃ­o o con espacios
        El programa debe:
            Convertir correctamente los nÃºmeros
            Ignorar entradas invÃ¡lidas
            Contar cuÃ¡ntos valores vÃ¡lidos hay
            Evitar que el programa falle ante valores nulos
    ğŸ“¤ Entrada de ejemplo
        " 10 ; 20 ; ; 30.5 ; hola ; null ; 40 "
    ğŸ“¤ Salida esperada (conceptual)
        Enteros vÃ¡lidos: X
        Decimales vÃ¡lidos: Y
        Entradas vacÃ­as: Z
    ğŸ”¥ Lo que se evalÃºa
        Manejo de String
        Uso correcto de wrappers
        Autoboxing / unboxing seguro
        Control de NullPointerException
        Uso eficiente de memoria

ğŸš€ PROYECTO 2 â€” Generador de Reportes de Texto (OptimizaciÃ³n)
    ğŸ“Œ Contexto
        Se necesita generar un reporte grande en texto (simula logs o reportes backend).
    ğŸ§© Requisitos
        Genera un reporte con 1000 lÃ­neas
        Cada lÃ­nea debe incluir:
            NÃºmero de lÃ­nea
            Texto formateado
        El reporte final debe ser una sola cadena
        Debe ser fÃ¡cil cambiar entre:
            ImplementaciÃ³n ineficiente
            ImplementaciÃ³n optimizada
    ğŸ“¤ Ejemplo de lÃ­nea
        Linea 25: procesamiento correcto
    ğŸ”¥ Lo que se evalÃºa
        Uso correcto de String vs StringBuilder
        Conciencia del impacto en el Heap
        Inmutabilidad de String
        Rendimiento en concatenaciones

ğŸš€ PROYECTO 3 â€” Normalizador de Texto para Backend
    ğŸ“Œ Contexto
        Un backend recibe texto desordenado de mÃºltiples fuentes.
    ğŸ§© Requisitos
        Recibe un texto largo
        Normaliza el texto para almacenamiento:
            Elimina espacios innecesarios
            Unifica mayÃºsculas/minÃºsculas
            Reemplaza palabras clave
        Detecta:
            Texto vacÃ­o
            Texto con solo espacios
        Devuelve un resultado limpio y consistente
    ğŸ“¤ Entrada ejemplo
        "   Java   es   GENIAL   "
    ğŸ“¤ Salida esperada
        "java es genial"
    ğŸ”¥ Lo que se evalÃºa
        trim() / strip()
        replace()
        isEmpty() vs isBlank()
        ManipulaciÃ³n segura de Strings
        DiseÃ±o limpio de mÃ©todos


##########################################################
################ TIPOS DE DATOS Y MEMORIA ################
##########################################################

ğŸš€ PROYECTO 4 â€” Motor de Decisiones (Switch Expressions)
    ğŸ“Œ Contexto
        Un sistema necesita decidir acciones segÃºn un cÃ³digo de operaciÃ³n recibido como texto.
    ğŸ§© Requisitos
    Recibe un cÃ³digo de operaciÃ³n (String)
    Soporta mÃºltiples tipos de operaciÃ³n:
        Operaciones simples
        Operaciones agrupadas
        Operaciones invÃ¡lidas
    Cada operaciÃ³n devuelve un resultado, no solo ejecuta cÃ³digo
    El sistema debe:
        Usar switch expressions modernas
        Retornar valores distintos segÃºn la lÃ³gica
        Tener al menos un caso con lÃ³gica compleja (no una sola lÃ­nea)
    ğŸ“¤ Entrada de ejemplo
        "CREATE"
    ğŸ“¤ Salida esperada (conceptual)
        Operacion permitida: true
        Descripcion: Creacion de recurso
    ğŸ”¥ Lo que se evalÃºa
        Uso de switch como expresiÃ³n
        Uso correcto de ->
        Uso de yield
        EliminaciÃ³n de break innecesario
        CÃ³digo limpio y expresivo


##########################################################
############ CLASE UTILITARIA java.util.Arrays ###########
##########################################################

ğŸš€ PROYECTO 5 â€” Motor de Ranking de Resultados
    ğŸ“Œ Contexto
        Un sistema necesita ordenar y clasificar resultados numÃ©ricos para mostrar un ranking.
    ğŸ§© Requisitos
        El sistema recibe un arreglo de valores numÃ©ricos
        Debe generar un ranking ordenado
        Se deben realizar bÃºsquedas rÃ¡pidas de valores especÃ­ficos
        El arreglo original no debe modificarse
        El resultado final debe ser un nuevo arreglo
    ğŸ“¤ Entrada conceptual
        [78, 95, 60, 88, 92]
    ğŸ“¤ Salida conceptual
        Ranking ordenado: [60, 78, 88, 92, 95]
        PosiciÃ³n del valor 88: X
    ğŸ”¥ Lo que se evalÃºa
        Ordenamiento eficiente
        BÃºsqueda binaria correcta
        Manejo seguro de arreglos
        ComprensiÃ³n de copias vs referencias

ğŸš€ PROYECTO 6 â€” CatÃ¡logo Inmutable de Datos
    ğŸ“Œ Contexto
        Un backend expone un catÃ¡logo de valores que no debe modificarse accidentalmente.
    ğŸ§© Requisitos
        Parte de un arreglo base de elementos
        El catÃ¡logo debe exponerse como lista
        El sistema debe:
            Permitir lectura
            Rechazar modificaciones estructurales
        Debe quedar claro quÃ© operaciones estÃ¡n permitidas y cuÃ¡les no
    ğŸ“¤ Entrada conceptual
        ["A", "B", "C"]
    ğŸ“¤ Salida conceptual
        Catalogo cargado correctamente
        Intento de modificacion rechazado
    ğŸ”¥ Lo que se evalÃºa
        Uso consciente de Arrays.asList()
        Entendimiento de listas de tamaÃ±o fijo
        Diferencia entre modificar elementos y estructura
        DiseÃ±o defensivo

ğŸš€ PROYECTO 7 â€” Gestor de Versiones de Datos
    ğŸ“Œ Contexto
        Un sistema mantiene distintas versiones de un conjunto de datos.
    ğŸ§© Requisitos
        Parte de un arreglo original
        Permite crear nuevas versiones del arreglo
        Cada versiÃ³n puede:
            Tener distinto tamaÃ±o
            Mantener los datos anteriores
        Ninguna versiÃ³n debe afectar a las demÃ¡s
    ğŸ“¤ Entrada conceptual
        Version 1: [10, 20, 30]
    ğŸ“¤ Salida conceptual
        Version 2: [10, 20, 30, 40]
        Version 3: [10, 20]
    ğŸ”¥ Lo que se evalÃºa
        Uso correcto de copias de arreglos
        Manejo de memoria
        Inmutabilidad por diseÃ±o
        Uso correcto de utilidades estÃ¡ndar
