##########################################################
################ TIPOS DE DATOS Y MEMORIA ################
##########################################################

ğŸš€ PROYECTO 1 â€” Analizador de Entradas del Usuario
    ğŸ“Œ Contexto
        Un programa recibe datos como texto (simulando una API o un formulario).
    ğŸ§© Requisitos
        Recibe un String con datos separados por ;
        Cada dato puede ser:
            Un nÃºmero entero
            Un nÃºmero decimal
            Texto vacÃ­o o con espacios
        El programa debe:
            Convertir correctamente los nÃºmeros
            Ignorar entradas invÃ¡lidas
            Contar cuÃ¡ntos valores vÃ¡lidos hay
            Evitar que el programa falle ante valores nulos
    ğŸ“¤ Entrada de ejemplo
        " 10 ; 20 ; ; 30.5 ; hola ; null ; 40 "
    ğŸ“¤ Salida esperada (conceptual)
        Enteros vÃ¡lidos: X
        Decimales vÃ¡lidos: Y
        Entradas vacÃ­as: Z
    ğŸ”¥ Lo que se evalÃºa
        Manejo de String
        Uso correcto de wrappers
        Autoboxing / unboxing seguro
        Control de NullPointerException
        Uso eficiente de memoria

ğŸš€ PROYECTO 2 â€” Generador de Reportes de Texto (OptimizaciÃ³n)
    ğŸ“Œ Contexto
        Se necesita generar un reporte grande en texto (simula logs o reportes backend).
    ğŸ§© Requisitos
        Genera un reporte con 1000 lÃ­neas
        Cada lÃ­nea debe incluir:
            NÃºmero de lÃ­nea
            Texto formateado
        El reporte final debe ser una sola cadena
        Debe ser fÃ¡cil cambiar entre:
            ImplementaciÃ³n ineficiente
            ImplementaciÃ³n optimizada
    ğŸ“¤ Ejemplo de lÃ­nea
        Linea 25: procesamiento correcto
    ğŸ”¥ Lo que se evalÃºa
        Uso correcto de String vs StringBuilder
        Conciencia del impacto en el Heap
        Inmutabilidad de String
        Rendimiento en concatenaciones

ğŸš€ PROYECTO 3 â€” Normalizador de Texto para Backend
    ğŸ“Œ Contexto
        Un backend recibe texto desordenado de mÃºltiples fuentes.
    ğŸ§© Requisitos
        Recibe un texto largo
        Normaliza el texto para almacenamiento:
            Elimina espacios innecesarios
            Unifica mayÃºsculas/minÃºsculas
            Reemplaza palabras clave
        Detecta:
            Texto vacÃ­o
            Texto con solo espacios
        Devuelve un resultado limpio y consistente
    ğŸ“¤ Entrada ejemplo
        "   Java   es   GENIAL   "
    ğŸ“¤ Salida esperada
        "java es genial"
    ğŸ”¥ Lo que se evalÃºa
        trim() / strip()
        replace()
        isEmpty() vs isBlank()
        ManipulaciÃ³n segura de Strings
        DiseÃ±o limpio de mÃ©todos


##########################################################
################ TIPOS DE DATOS Y MEMORIA ################
##########################################################

ğŸš€ PROYECTO 4 â€” Motor de Decisiones (Switch Expressions)
    ğŸ“Œ Contexto
        Un sistema necesita decidir acciones segÃºn un cÃ³digo de operaciÃ³n recibido como texto.
    ğŸ§© Requisitos
    Recibe un cÃ³digo de operaciÃ³n (String)
    Soporta mÃºltiples tipos de operaciÃ³n:
        Operaciones simples
        Operaciones agrupadas
        Operaciones invÃ¡lidas
    Cada operaciÃ³n devuelve un resultado, no solo ejecuta cÃ³digo
    El sistema debe:
        Usar switch expressions modernas
        Retornar valores distintos segÃºn la lÃ³gica
        Tener al menos un caso con lÃ³gica compleja (no una sola lÃ­nea)
    ğŸ“¤ Entrada de ejemplo
        "CREATE"
    ğŸ“¤ Salida esperada (conceptual)
        Operacion permitida: true
        Descripcion: Creacion de recurso
    ğŸ”¥ Lo que se evalÃºa
        Uso de switch como expresiÃ³n
        Uso correcto de ->
        Uso de yield
        EliminaciÃ³n de break innecesario
        CÃ³digo limpio y expresivo

ğŸš€ PROYECTO 5 â€” Procesador de Colecciones (for-each e Iterable)
ğŸ“Œ Contexto
    Un sistema procesa colecciones de datos sin conocer su implementaciÃ³n interna.
ğŸ§© Requisitos
    Recibe una colecciÃ³n de elementos
    El sistema debe:
        Recorrer los elementos sin usar Ã­ndices
        Ejecutar una acciÃ³n sobre cada elemento
        Permitir detener el procesamiento bajo ciertas condiciones
    El diseÃ±o debe:
        No depender de List directamente
        Funcionar con cualquier estructura iterable
ğŸ“¤ Entrada conceptual
    ColecciÃ³n de tareas
ğŸ“¤ Salida conceptual
    Procesando tarea A
    Procesando tarea B
    Procesamiento detenido
ğŸ”¥ Lo que se evalÃºa
    Uso real de for-each
    ComprensiÃ³n de Iterable
    Diferencia entre Iterator y bucle tradicional
    Control del flujo durante la iteraciÃ³n
    