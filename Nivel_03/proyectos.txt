##########################################################
################## GENERICS (GENERICOS) ##################
##########################################################

ğŸš€ PROYECTO 1 â€” Repositorio GenÃ©rico (DAO bÃ¡sico)
    ğŸ“Œ Caso real
        EstÃ¡s creando la capa de acceso a datos de un backend.
        No quieres repetir cÃ³digo para Usuario, Producto, Cliente, etc.
    ğŸ§© Requisitos
        Crea una clase genÃ©rica:
            public class Repositorio<T>
        Debe permitir:
            guardar(T entidad)
            eliminar(T entidad)
            List<T> listar()
    ğŸ› ï¸ Condiciones
        Usa List<T> internamente
        Implementa toString() para mostrar el contenido
        Crea al menos 2 entidades distintas:
            Usuario
            Producto
        Usa el mismo repositorio para ambos
    ğŸ§  Aprendes
        âœ” Sintaxis <T>
        âœ” ReutilizaciÃ³n real de cÃ³digo
        âœ” CÃ³mo Java mantiene seguridad de tipos
        âœ” Por quÃ© no puedes hacer new T()

ğŸš€ PROYECTO 2 â€” Procesador de Listas con Wildcards
    ğŸ“Œ Caso real
        EstÃ¡s escribiendo utilidades comunes que trabajan con listas de diferentes tipos, pero sin modificarlas.
    ğŸ§© Requisitos
        Crea una clase ProcesadorListas con mÃ©todos:
        1ï¸âƒ£ MÃ©todo SOLO lectura (Upper Bound)
            public static void imprimirNombres(List<? extends Persona> lista)
            Persona tiene getNombre()
            Acepta List<Persona>, List<Empleado>, List<Cliente>
            âŒ No permite agregar elementos
        2ï¸âƒ£ MÃ©todo SOLO escritura (Lower Bound)
            public static void agregarEmpleado(List<? super Empleado> lista)
            Permite agregar Empleado
            Acepta List<Empleado>, List<Persona>, List<Object>
    ğŸ§  Regla de oro (real)
        PECS
        Producer â†’ extends
        Consumer â†’ super
    ğŸ§  Aprendes
        âœ” List<?>
        âœ” ? extends T (solo leer)
        âœ” ? super T (solo escribir)
        âœ” Errores tÃ­picos del compilador

ğŸš€ PROYECTO 3 â€” Sistema de Cache GenÃ©rico (Type Erasure en acciÃ³n)
    ğŸ“Œ Caso real
        Implementas un sistema de cache reutilizable para distintos tipos.
    ğŸ§© Requisitos
        Crea una clase:
            public class Cache<K, V>
        Debe permitir:
            put(K clave, V valor)
            V get(K clave)
            boolean contieneClave(K clave)
    ğŸ› ï¸ Restricciones clave
        Usa internamente un HashMap<K, V>
        NO puedes hacer:
            if (valor instanceof V) { }
    ğŸ§  Pregunta crÃ­tica
        Â¿Por quÃ© esto NO compila?
            if (obj instanceof V) { }
    ğŸ§  Type Erasure explicado (en este ejercicio)
        En tiempo de ejecuciÃ³n:
            Cache<String, Usuario>
            Cache<Integer, Producto>
        â¡ï¸ Ambos se convierten en:
            Cache
        ğŸ‘‰ Los tipos genÃ©ricos desaparecen
    ğŸ§  Aprendes
        âœ” <K, V> en escenarios reales
        âœ” LÃ­mites reales del runtime
        âœ” Por quÃ© Java usa Type Erasure
        âœ” ComparaciÃ³n con otros lenguajes (C#, Kotlin)

##########################################################
########################## LIST ##########################
##########################################################

ğŸš€ PROYECTO 4 â€” Historial de acciones de un usuario
    ğŸ“Œ Caso real
        EstÃ¡s desarrollando un sistema que guarda el historial de acciones de un usuario (login, ver perfil, cerrar sesiÃ³n, etc.).
        Las acciones se agregan constantemente y a veces se eliminan las mÃ¡s antiguas.
    ğŸ§© Requisitos
        Clase Accion con:
            tipo
            fechaHora
        Una lista para almacenar el historial
        MÃ©todos:
            agregarAccionInicio(Accion accion)
            eliminarUltimaAccion()
            mostrarHistorial()
    ğŸ› ï¸ Condiciones
        Usa LinkedList<Accion>
        Inserta acciones al inicio de la lista
        Elimina acciones del final
        No usar Ã­ndices directamente (get(i))
    ğŸ§  Aprendes
        Por quÃ© LinkedList es ideal para inserciones/eliminaciones
        Diferencia real entre nodos vs array
        Coste oculto de add(0, elemento) en ArrayList

ğŸš€ PROYECTO 5 â€” CatÃ¡logo de productos (lectura intensiva)
    ğŸ“Œ Caso real
        Un e-commerce carga un catÃ¡logo de productos que se consulta miles de veces por segundo, pero casi no cambia.
    ğŸ§© Requisitos
        Clase Producto:
            id
            nombre
            precio
        Lista de productos
        MÃ©todos:
            buscarProductoPorIndice(int i)
            listarProductos()
    ğŸ› ï¸ Condiciones
        Usa ArrayList<Producto>
        Accede a productos usando get(i)
        No elimines ni insertes en medio de la lista
    ğŸ§  Aprendes
        Por quÃ© ArrayList es superior para lectura
        Acceso directo O(1)
        Casos donde LinkedList es una mala elecciÃ³n

ğŸš€ PROYECTO 6 â€” Cola de tareas en un servidor
    ğŸ“Œ Caso real
        Un servidor procesa tareas en orden de llegada (FIFO).
        Las tareas entran y salen constantemente.
    ğŸ§© Requisitos
        Clase Tarea:
            id
            descripcion
        Lista de tareas pendientes
        MÃ©todos:
            agregarTarea(Tarea tarea)
            procesarSiguiente()
            verTareasPendientes()
    ğŸ› ï¸ Condiciones
        Usa LinkedList<Tarea>
        Agrega tareas al final
        Procesa tareas desde el inicio
        No usar ArrayList
    ğŸ§  Aprendes
        Implementar una cola real con List
        Por quÃ© remove(0) es costoso en ArrayList
        Uso correcto de LinkedList como estructura dinÃ¡mica

##########################################################
########################## SET ###########################
##########################################################

ğŸš€ PROYECTO 7 â€” Registro de correos Ãºnicos (newsletter)
    ğŸ“Œ Caso real
        Un sistema de newsletter debe almacenar correos electrÃ³nicos de usuarios sin permitir duplicados, y el orden no importa.
    ğŸ§© Requisitos
        Clase Correo o usar directamente String
        Un conjunto para almacenar los correos registrados
        MÃ©todos:
            registrarCorreo(String email)
            mostrarCorreos()
            totalCorreos()
    ğŸ› ï¸ Condiciones
        Usa HashSet<String>
        No permitir correos duplicados
        No asumir ningÃºn orden al imprimir
        Mostrar el total de correos Ãºnicos
    ğŸ§  Aprendes
        QuÃ© significa realmente â€œsin duplicadosâ€
        Por quÃ© HashSet no mantiene orden
        Uso real de hashCode() y equals()

ğŸš€ PROYECTO 8 â€” Historial de dispositivos conectados
    ğŸ“Œ Caso real
        Un sistema registra los dispositivos que se han conectado a una red, y necesita mostrar el orden exacto en el que se conectaron.
    ğŸ§© Requisitos
        Clase Dispositivo:
            id
            nombre
        Un conjunto de dispositivos
        MÃ©todos:
            conectarDispositivo(Dispositivo d)
            mostrarDispositivosConectados()
    ğŸ› ï¸ Condiciones
        Usa LinkedHashSet<Dispositivo>
        Evitar dispositivos duplicados por id
        Mantener el orden de inserciÃ³n
        Sobrescribir equals() y hashCode()
    ğŸ§  Aprendes
        Diferencia prÃ¡ctica entre HashSet y LinkedHashSet
        Por quÃ© el orden puede ser importante
        Casos reales donde el orden de inserciÃ³n importa

ğŸš€ PROYECTO 9 â€” Ranking de puntuaciones (orden automÃ¡tico)
ğŸ“Œ Caso real
    Un videojuego mantiene un ranking de puntuaciones, donde no se repiten puntajes y deben mostrarse ordenados.
ğŸ§© Requisitos
    Clase Puntaje:
        valor
        jugador
    Un conjunto de puntajes
    MÃ©todo:
        mostrarRanking()
ğŸ› ï¸ Condiciones
    Usa TreeSet<Puntaje>
    Ordenar por:
        Puntaje descendente
        Si empatan, ordenar por nombre del jugador
    Implementar Comparable o usar un Comparator
ğŸ§  Aprendes
    QuÃ© hace especial a TreeSet
    Orden natural vs orden personalizado
    Diferencia entre igualdad lÃ³gica y ordenamiento

##########################################################
########################## MAP ###########################
##########################################################

ğŸš€ PROYECTO 10 â€” Conteo de visitas a pÃ¡ginas (analÃ­tica web)
    ğŸ“Œ Caso real
        Un sistema de analÃ­tica registra cuÃ¡ntas veces se visita cada pÃ¡gina de un sitio web.
        El orden no importa, lo importante es contar rÃ¡pido.
    ğŸ§© Requisitos
        Usar la URL de la pÃ¡gina como clave (String)
        Usar el nÃºmero de visitas como valor (Integer)
        MÃ©todos:
            registrarVisita(String url)
            mostrarEstadisticas()
    ğŸ› ï¸ Condiciones
        Usar HashMap<String, Integer>
        Incrementar visitas usando:
            containsKey() o
            getOrDefault()
        Recorrer el mapa con entrySet()
        No asumir ningÃºn orden al imprimir
    ğŸ§  Aprendes
        Funcionamiento prÃ¡ctico de HashMap
        RelaciÃ³n entre hashCode, colisiones y buckets
        Uso correcto de getOrDefault() y entrySet()

ğŸš€ PROYECTO 11 â€” Agenda telefÃ³nica ordenada
    ğŸ“Œ Caso real
        Una agenda de contactos debe mostrarse ordenada alfabÃ©ticamente por nombre, sin importar el orden de inserciÃ³n.
    ğŸ§© Requisitos
        Clave: nombre del contacto (String)
        Valor: nÃºmero telefÃ³nico (String)
        MÃ©todos:
            agregarContacto(String nombre, String telefono)
            buscarTelefono(String nombre)
            mostrarAgenda()
    ğŸ› ï¸ Condiciones
        Usar TreeMap<String, String>
        Obtener telÃ©fonos con get()
        Verificar existencia con containsKey()
        Mostrar la agenda recorriendo keySet() o entrySet()
    ğŸ§  Aprendes
        Orden automÃ¡tico de claves en TreeMap
        Diferencia real entre HashMap y TreeMap
        CuÃ¡ndo el orden es responsabilidad del Map

