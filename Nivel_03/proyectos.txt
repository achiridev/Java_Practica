##########################################################
################## GENERICS (GENERICOS) ##################
##########################################################

ğŸš€ PROYECTO 1 â€” Repositorio GenÃ©rico (DAO bÃ¡sico)
    ğŸ“Œ Caso real
        EstÃ¡s creando la capa de acceso a datos de un backend.
        No quieres repetir cÃ³digo para Usuario, Producto, Cliente, etc.
    ğŸ§© Requisitos
        Crea una clase genÃ©rica:
            public class Repositorio<T>
        Debe permitir:
            guardar(T entidad)
            eliminar(T entidad)
            List<T> listar()
    ğŸ› ï¸ Condiciones
        Usa List<T> internamente
        Implementa toString() para mostrar el contenido
        Crea al menos 2 entidades distintas:
            Usuario
            Producto
        Usa el mismo repositorio para ambos
    ğŸ§  Aprendes
        âœ” Sintaxis <T>
        âœ” ReutilizaciÃ³n real de cÃ³digo
        âœ” CÃ³mo Java mantiene seguridad de tipos
        âœ” Por quÃ© no puedes hacer new T()

ğŸš€ PROYECTO 2 â€” Procesador de Listas con Wildcards
    ğŸ“Œ Caso real
        EstÃ¡s escribiendo utilidades comunes que trabajan con listas de diferentes tipos, pero sin modificarlas.
    ğŸ§© Requisitos
        Crea una clase ProcesadorListas con mÃ©todos:
        1ï¸âƒ£ MÃ©todo SOLO lectura (Upper Bound)
            public static void imprimirNombres(List<? extends Persona> lista)
            Persona tiene getNombre()
            Acepta List<Persona>, List<Empleado>, List<Cliente>
            âŒ No permite agregar elementos
        2ï¸âƒ£ MÃ©todo SOLO escritura (Lower Bound)
            public static void agregarEmpleado(List<? super Empleado> lista)
            Permite agregar Empleado
            Acepta List<Empleado>, List<Persona>, List<Object>
    ğŸ§  Regla de oro (real)
        PECS
        Producer â†’ extends
        Consumer â†’ super
    ğŸ§  Aprendes
        âœ” List<?>
        âœ” ? extends T (solo leer)
        âœ” ? super T (solo escribir)
        âœ” Errores tÃ­picos del compilador

ğŸš€ PROYECTO 3 â€” Sistema de Cache GenÃ©rico (Type Erasure en acciÃ³n)
    ğŸ“Œ Caso real
        Implementas un sistema de cache reutilizable para distintos tipos.
    ğŸ§© Requisitos
        Crea una clase:
            public class Cache<K, V>
        Debe permitir:
            put(K clave, V valor)
            V get(K clave)
            boolean contieneClave(K clave)
    ğŸ› ï¸ Restricciones clave
        Usa internamente un HashMap<K, V>
        NO puedes hacer:
            if (valor instanceof V) { }
    ğŸ§  Pregunta crÃ­tica
        Â¿Por quÃ© esto NO compila?
            if (obj instanceof V) { }
    ğŸ§  Type Erasure explicado (en este ejercicio)
        En tiempo de ejecuciÃ³n:
            Cache<String, Usuario>
            Cache<Integer, Producto>
        â¡ï¸ Ambos se convierten en:
            Cache
        ğŸ‘‰ Los tipos genÃ©ricos desaparecen
    ğŸ§  Aprendes
        âœ” <K, V> en escenarios reales
        âœ” LÃ­mites reales del runtime
        âœ” Por quÃ© Java usa Type Erasure
        âœ” ComparaciÃ³n con otros lenguajes (C#, Kotlin)

##########################################################
########################## LIST ##########################
##########################################################

ğŸš€ PROYECTO 4 â€” Historial de acciones de un usuario
    ğŸ“Œ Caso real
        EstÃ¡s desarrollando un sistema que guarda el historial de acciones de un usuario (login, ver perfil, cerrar sesiÃ³n, etc.).
        Las acciones se agregan constantemente y a veces se eliminan las mÃ¡s antiguas.
    ğŸ§© Requisitos
        Clase Accion con:
            tipo
            fechaHora
        Una lista para almacenar el historial
        MÃ©todos:
            agregarAccionInicio(Accion accion)
            eliminarUltimaAccion()
            mostrarHistorial()
    ğŸ› ï¸ Condiciones
        Usa LinkedList<Accion>
        Inserta acciones al inicio de la lista
        Elimina acciones del final
        No usar Ã­ndices directamente (get(i))
    ğŸ§  Aprendes
        Por quÃ© LinkedList es ideal para inserciones/eliminaciones
        Diferencia real entre nodos vs array
        Coste oculto de add(0, elemento) en ArrayList

ğŸš€ PROYECTO 5 â€” CatÃ¡logo de productos (lectura intensiva)
    ğŸ“Œ Caso real
        Un e-commerce carga un catÃ¡logo de productos que se consulta miles de veces por segundo, pero casi no cambia.
    ğŸ§© Requisitos
        Clase Producto:
            id
            nombre
            precio
        Lista de productos
        MÃ©todos:
            buscarProductoPorIndice(int i)
            listarProductos()
    ğŸ› ï¸ Condiciones
        Usa ArrayList<Producto>
        Accede a productos usando get(i)
        No elimines ni insertes en medio de la lista
    ğŸ§  Aprendes
        Por quÃ© ArrayList es superior para lectura
        Acceso directo O(1)
        Casos donde LinkedList es una mala elecciÃ³n

ğŸš€ PROYECTO 6 â€” Cola de tareas en un servidor
    ğŸ“Œ Caso real
        Un servidor procesa tareas en orden de llegada (FIFO).
        Las tareas entran y salen constantemente.
    ğŸ§© Requisitos
        Clase Tarea:
            id
            descripcion
        Lista de tareas pendientes
        MÃ©todos:
            agregarTarea(Tarea tarea)
            procesarSiguiente()
            verTareasPendientes()
    ğŸ› ï¸ Condiciones
        Usa LinkedList<Tarea>
        Agrega tareas al final
        Procesa tareas desde el inicio
        No usar ArrayList
    ğŸ§  Aprendes
        Implementar una cola real con List
        Por quÃ© remove(0) es costoso en ArrayList
        Uso correcto de LinkedList como estructura dinÃ¡mica

