##########################################################
################## GENERICS (GENERICOS) ##################
##########################################################

ğŸš€ PROYECTO 1 â€” Repositorio GenÃ©rico (DAO bÃ¡sico)
    ğŸ“Œ Caso real
        EstÃ¡s creando la capa de acceso a datos de un backend.
        No quieres repetir cÃ³digo para Usuario, Producto, Cliente, etc.
    ğŸ§© Requisitos
        Crea una clase genÃ©rica:
            public class Repositorio<T>
        Debe permitir:
            guardar(T entidad)
            eliminar(T entidad)
            List<T> listar()
    ğŸ› ï¸ Condiciones
        Usa List<T> internamente
        Implementa toString() para mostrar el contenido
        Crea al menos 2 entidades distintas:
            Usuario
            Producto
        Usa el mismo repositorio para ambos
    ğŸ§  Aprendes
        âœ” Sintaxis <T>
        âœ” ReutilizaciÃ³n real de cÃ³digo
        âœ” CÃ³mo Java mantiene seguridad de tipos
        âœ” Por quÃ© no puedes hacer new T()

ğŸš€ PROYECTO 2 â€” Procesador de Listas con Wildcards
    ğŸ“Œ Caso real
        EstÃ¡s escribiendo utilidades comunes que trabajan con listas de diferentes tipos, pero sin modificarlas.
    ğŸ§© Requisitos
        Crea una clase ProcesadorListas con mÃ©todos:
        1ï¸âƒ£ MÃ©todo SOLO lectura (Upper Bound)
            public static void imprimirNombres(List<? extends Persona> lista)
            Persona tiene getNombre()
            Acepta List<Persona>, List<Empleado>, List<Cliente>
            âŒ No permite agregar elementos
        2ï¸âƒ£ MÃ©todo SOLO escritura (Lower Bound)
            public static void agregarEmpleado(List<? super Empleado> lista)
            Permite agregar Empleado
            Acepta List<Empleado>, List<Persona>, List<Object>
    ğŸ§  Regla de oro (real)
        PECS
        Producer â†’ extends
        Consumer â†’ super
    ğŸ§  Aprendes
        âœ” List<?>
        âœ” ? extends T (solo leer)
        âœ” ? super T (solo escribir)
        âœ” Errores tÃ­picos del compilador

ğŸš€ PROYECTO 3 â€” Sistema de Cache GenÃ©rico (Type Erasure en acciÃ³n)
    ğŸ“Œ Caso real
        Implementas un sistema de cache reutilizable para distintos tipos.
    ğŸ§© Requisitos
        Crea una clase:
            public class Cache<K, V>
        Debe permitir:
            put(K clave, V valor)
            V get(K clave)
            boolean contieneClave(K clave)
    ğŸ› ï¸ Restricciones clave
        Usa internamente un HashMap<K, V>
        NO puedes hacer:
            if (valor instanceof V) { }
    ğŸ§  Pregunta crÃ­tica
        Â¿Por quÃ© esto NO compila?
            if (obj instanceof V) { }
    ğŸ§  Type Erasure explicado (en este ejercicio)
        En tiempo de ejecuciÃ³n:
            Cache<String, Usuario>
            Cache<Integer, Producto>
        â¡ï¸ Ambos se convierten en:
            Cache
        ğŸ‘‰ Los tipos genÃ©ricos desaparecen
    ğŸ§  Aprendes
        âœ” <K, V> en escenarios reales
        âœ” LÃ­mites reales del runtime
        âœ” Por quÃ© Java usa Type Erasure
        âœ” ComparaciÃ³n con otros lenguajes (C#, Kotlin)

